# -*- coding: utf-8 -*-
"""Personal: AI (ML Clustering, Heiarchical).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ph_KzT0O_1EV5nly94HMlpXBAh0U34qV
"""

# Agglomerative Heiarchical Clustering: Avian Cluster
# Notes:
  # Two types of Heiarchical Clustering Algorithms: Agglomerative and Divisive.
  # Agglomerative: Data points are clustered using a bottom-up approach starting with individual data points.
  # Divisive: All the data points are treated as one big cluster, we later divide it into smaller clusters.

# Imports
# You can also use scipy, a library used for many things such as clustering, optimization, etc
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import scipy.cluster.hierarchy as heiarchy
from sklearn.cluster import AgglomerativeClustering

# Data
# Full dataset link: https://www.kaggle.com/datasets/zhangjuefei/birds-bones-and-living-habits
# Headers = huml, humw, ulnal, ulnaw, feml, femw, tibl, tibw, tarl, tarw
# Variables we will focus on = huml, tibl
# Ideally meant to have 6 clusters
dataset = pd.read_csv("//content//drive//MyDrive//Coding//Personal Projects//1: Artificial Intelligence//Resources//AvianAgglomerativeCluster.csv")
#dataset = dataset.iloc[:, [1,7]] # no need for ID or specie columns
dataset = dataset.iloc[:, 1:-1] # no need for ID or specie columns
dataset = dataset.values.tolist()

processedData = []

for row in dataset:
  addValue = True
  for column in range(0,len(row)):
    if str(row[column]) == "nan":
      addValue = False
  if addValue:
    processedData.append(row)

print(processedData)
print(len(dataset))
print(len(processedData))

# Cluster Graph
plt.figure(figsize=(10, 5))
plt.title("Avian Cluster Dendograms")
dend = heiarchy.dendrogram(heiarchy.linkage(processedData, method = "ward"))

# Cluster Algorithm
# Affinity = specify how to measure distances between points (manhattan, l1, l2, euclidian, etc)
# Linkage = specify how to link/cluster data points together
# "Ward Linkage" is a kind of linking algorithm that attempts to minimize variance in the clusters it makes
cluster = AgglomerativeClustering(n_clusters = 6, affinity = 'euclidean', linkage = 'ward')
cluster.fit_predict(processedData)
print(cluster.labels_)

# Scattergrams
# Due to the 2D nature of the graph, we will only show two variables per subplot
# Headers = huml, humw, ulnal, ulnaw, feml, femw, tibl, tibw, tarl, tarw
f = plt.figure()    
f, axes = plt.subplots(nrows = 3, ncols = 2)
processedData = np.array(processedData)
labelColors = ["Red", "Orange", "Yellow", "Green", "Blue", "Purple"]

axes[0][0].scatter(processedData[:,0], processedData[:,1], c = cluster.labels_, cmap = 'rainbow')
axes[0][0].set_xlabel('HUML', labelpad = 5)
axes[0][0].set_ylabel('HUMW', labelpad = 5)

axes[0][1].scatter(processedData[:,2], processedData[:,3], c = cluster.labels_, cmap = 'rainbow')
axes[0][1].set_xlabel('ULNAL', labelpad = 5)
axes[0][1].set_ylabel('ULNAW', labelpad = 5)

axes[1][0].scatter(processedData[:,4], processedData[:,5], c = cluster.labels_, cmap = 'rainbow')
axes[1][0].set_xlabel('FEML', labelpad = 5)
axes[1][0].set_ylabel('FEMW', labelpad = 5)

axes[1][1].scatter(processedData[:,6], processedData[:,7], c = cluster.labels_, cmap = 'rainbow')
axes[1][1].set_xlabel('TIBL', labelpad = 5)
axes[1][1].set_ylabel('TIBW', labelpad = 5)

axes[2][0].scatter(processedData[:,8], processedData[:,9], c = cluster.labels_, cmap = 'rainbow')
axes[2][0].set_xlabel('TARL', labelpad = 5)
axes[2][0].set_ylabel('TARW', labelpad = 5)

plt.show()